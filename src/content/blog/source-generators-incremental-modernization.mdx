---
title: "Source Generators for Incremental C# Modernization"
date: "2025-09-20"
author: "Mark Ewer"
slug: "source-generators-incremental-modernization"
description: "Hands-on guide to using C# Source Generators (Roslyn) to eliminate boilerplate and modernize a legacy codebase incrementally. Includes design goals, a step-by-step example (AutoNotify), testing, and rollout strategy."
tags: ["c#", "roslyn", "source-generators", "modernization", "dotnet"]
image: "/images/blog/building-ai-coding-assistant-primary.svg"
---

# Source Generators for Incremental C# Modernization

---

## TL;DR

C# Source Generators (Roslyn) give you a compile-time hook to generate code, remove boilerplate, and introduce modern patterns without runtime costs. This post walks through design goals, a practical `AutoNotify` example (INotifyPropertyChanged generation), testing strategies, and a low-risk rollout plan for large codebases.

---

## Motivation

Modernizing a large C# codebase is painful because boilerplate and repetitive patterns are everywhere: property change notifications, DTO mapping, `ToString()` implementations, and manual equality members. Source Generators let you solve those by emitting code during compilation — no runtime reflection, no fiddly T4 templates, and no manual, error-prone copy/paste.

They are especially useful when you want an incremental approach: annotate a few types, generate the code, and gradually expand coverage across the codebase.

---

## Roslyn Primer (Very Short)

At a high level, a Source Generator is a component that plugs into the Roslyn compilation pipeline and can:

- Inspect syntax and semantic models (what code looks like and what it means).
- Add or transform source code by producing new files (strings) that the compiler then compiles alongside your original code.

Prefer `IncrementalGenerator` (vs the older `ISourceGenerator`) because it provides performance benefits by running only when inputs change and offering better caching primitives in the compilation pipeline.

---

## When To Use Source Generators (and When Not To)

Use them for:

- Eliminating boilerplate (e.g., `INotifyPropertyChanged` backing fields).
- Compile-time code generation for serializers or helper methods.
- Generating strongly-typed adapters for reflection-based frameworks.

Avoid them when:

- Generation requires large runtime context (keep generators compile-time only).
- The generated code needs to be heavily customized per project — prefer templates or small helper libraries instead.

---

## Design Goals for a Production Generator

1. Deterministic: Generated output must be stable and repeatable.
2. Opt-in: Use attributes to opt specific classes into generation.
3. Minimal surprises: Generated member names should be predictable and avoid collisions.
4. Clear diagnostics: Emit helpful warnings and errors when generation can’t proceed.
5. Testable: Unit tests must be able to assert generated sources.
6. Incremental and fast: Use `IncrementalGenerator` APIs and restrict analysis scope.

---

## Hands‑On Example: `AutoNotify` Generator

We’ll build a simple `AutoNotify` generator that emits `INotifyPropertyChanged` boilerplate for annotated properties.

### What it does

- You mark an auto property with `[AutoNotify]`.
- The generator emits a backing field, the getter/setter, and raises `PropertyChanged` only when the value changes.

Example usage:

```csharp
using System.ComponentModel;

[AutoNotify]
public partial class Person : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler? PropertyChanged;

    [AutoNotify]
    public string FirstName { get; set; }

    [AutoNotify]
    public string LastName { get; set; }
}
```

Generated (conceptual):

```csharp
// <auto-generated />
partial class Person
{
    private string _firstName;
    public string FirstName
    {
        get => _firstName;
        set
        {
            if (!EqualityComparer<string>.Default.Equals(_firstName, value))
            {
                _firstName = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(FirstName)));
            }
        }
    }

    // ... LastName similar
}
```

### Project Setup

1. Create a class library project targeting `netstandard2.0` or `net6.0` (as required) with package references to `Microsoft.CodeAnalysis` and `Microsoft.CodeAnalysis.CSharp`.

2. Implement an `IncrementalGenerator` by creating a class that implements `IIncrementalGenerator`.

3. Define the attribute type (`AutoNotifyAttribute`) in a small shared assembly or emit the attribute from the generator when missing (convenient for consumers).

### Core generator pattern (high level)

- Use `context.SyntaxProvider.CreateSyntaxProvider(...)` with a predicate that finds candidate properties (e.g., properties with `[AutoNotify]`).
- Transform syntax nodes into semantic models and gather relevant data: containing type symbol, property symbol, property type, and attribute arguments.
- Register a `RegisterSourceOutput` that receives the collected data and writes generated code into `.g.cs` files using `context.AddSource(...)`.

A pseudo-snippet showing the incremental pipeline:

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    var candidates = context.SyntaxProvider
        .CreateSyntaxProvider(
            predicate: (node, ct) => IsPropertyWithAttribute(node),
            transform: (ctx, ct) => GetPropertyInfo(ctx))
        .Where(p => p is not null);

    var grouped = candidates.Collect();

    context.RegisterSourceOutput(grouped, (spc, collected) =>
    {
        // Build a compilation unit and add sources
        var generated = GenerateCode(collected);
        spc.AddSource("AutoNotify.g.cs", generated);
    });
}
```

### Avoiding common pitfalls

- **Name collisions**: Prefix generated fields (`_generatedFieldName`) and avoid overwriting existing members.
- **Partial type requirement**: Document that types must be `partial` to receive generated members.
- **Attribute presence**: If you choose to emit the attribute, do so under your generator namespace to avoid conflicts.

---

## Testing & Debugging

- Use `Microsoft.CodeAnalysis.CSharp.Testing` (and `Verify` helpers) to assert that given input source produces expected generated output.
- Write tests that:
  - Provide input source (a class with `[AutoNotify]`).
  - Run the generator.
  - Assert generated file content (or snapshots).

Debugging in Visual Studio:

- Create a console app that references the generator project as a debugger target and set breakpoints inside the generator.
- Use `Debugger.Launch()` in development to attach to a running instance.

---

## CI & Packaging

- Package the generator as an analyzer NuGet package (include `analyzers/dotnet/cs/`).
- Add it as a `PackageReference` with `OutputItemType=Analyzer` (or rely on SDK auto-discovery).
- Consider publishing to an internal NuGet feed for enterprise usage.
- Pin generator versions in `Directory.Build.props` to keep reproducible builds.

---

## Performance & Safety Tips

- Keep analysis scope narrow: only inspect syntax nodes that match your target pattern (`[AutoNotify]` attribute present).
- Avoid heavy semantic queries inside hot loops — friendly caching and incremental APIs help.
- Emit clear diagnostics (`context.ReportDiagnostic`) when generation can’t proceed (e.g., non-partial class, incompatible member signature).

---

## Migration Strategy for Large Codebases

1. **Pilot**: Start with a small, well-tested module.
2. **Opt-in**: Require an attribute to opt a type into generation.
3. **Measure**: Track build times and test suites before/after generator adoption.
4. **Iterate**: Expand to other modules and collect developer feedback.
5. **Code Review**: Treat generated code as part of the PR — surface generated output or CI checks to reviewers.

This incremental approach reduces risk and lets teams adopt generators at their own pace.

---

## Example Resources & Further Reading

- Roslyn docs: https://learn.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview
- Incremental Generators: https://github.com/dotnet/roslyn-sdk/blob/main/docs/Incremental%20Generators.md
- `Microsoft.CodeAnalysis.CSharp.Testing` for unit-testing generators

---

## Conclusion

Source Generators are a pragmatic and powerful way to modernize C# codebases incrementally. They remove boilerplate, are performant (compile-time only), and can be introduced with minimal disruption when designed with opt-in attributes, solid diagnostics, and careful testing. Start small, measure the impact, and grow adoption as confidence builds.

Happy modernizing!

